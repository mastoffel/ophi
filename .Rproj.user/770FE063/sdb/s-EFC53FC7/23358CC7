{
    "contents" : "## checking MinMod with joes data\n# extract coefficients from final models --> fitted values\n# fit every single snp in a model\n# + \n\n\n# load data---------------------------------------------------------------------\nophi_code <- read.table(\"./data/Ophionotus_GLM_4.txt\", \n                      colClasses = c(rep(\"numeric\",2),rep(\"factor\",98)), \n                      header = TRUE, row.names = NULL)\n\n# ophi as het, numeric\nophi_het <- read.csv(\"./data/joedata.csv\",\n                     colClasses = c(rep(\"numeric\",2),rep(\"numeric\",98)), \n                     header = TRUE)\n\nophi_het[, 2] <- ophi_code$disc_size\nnames(ophi_het)[2] <- \"disc_size\"\n\n# ophi as numeric\nophi_add <-  read.table(\"./data/Ophionotus_GLM_4.txt\", \n                               colClasses = c(rep(\"numeric\",100)), \n                               header = TRUE, row.names = NULL)\nophi_add[, 3:ncol(ophi_add)] <- ophi_add[, 3:ncol(ophi_add)] - 2\n\n\n# single variable deletion testing----------------------------------------------\nlibrary(minmodelr)\nsingle_add <- DelTestVar(ophi_add)\nsingle_het <- DelTestVar(ophi_het)\n\n\n# methods for best model selection----------------------------------------------\n\nlibrary(leaps)\nday_falling <- ophi_add$day_falling\ninp_mat_add <- ophi_add[, -1]\ninp_mat_het <- ophi_het[, -1]\ninp_mat_code <- ophi_code[, -1]\n\n\n\n# doesnt work for het because of factors, turn to numeric\ninp_mat_het[] <- lapply(inp_mat_het, as.numeric)\n\nregsub <- regsubsets(x = inp_mat_het, y = day_falling, \n                     nbest = 1, nvmax = 30, method = \"backward\",\n                     really.big = T)\n\n\nplot(regsub, scale = \"adjr2\", main = \"Adjusted R^2 - best models for 1-30 predictors\")\nplot(regsub, scale = \"r2\", main = \"R^2 - best models for 1-30 predictors\")\nplot(regsub, scale = \"bic\", main = \"BIC - best models for 1-30 predictors\")\nplot(regsub, scale = \"Cp\", main = \"Mallow´s Cp - best models for 1-30 predictors\")\n\n# using bestglm ----------------------------------------------------------------\n\nlibrary(bestglm)\n\n# additive model with AIC-------------------------------------------------------\n\nXy <- cbind(inp_mat_add, day_falling)\n# AIC backwards algorithm\nbest_add <- bestglm(Xy, IC = \"AIC\", method = \"backward\")\n# glm object containing final best model\nbestmod_add <- best_add$BestModel\n# preparing for full_table function with uses DelTestVar for\n# single deletion testing and puts the final SNP´s into the full SNP table (98)\nvarnames <- names(bestmod_add$coef)[-1]\nbestdf_add <- cbind(day_falling, inp_mat_add[varnames])\n\nsource(\"full_table.R\")\n# reference table should just contain snp row names\ntable_add_AIC <- full_table(bestdf_add, inp_mat_add[-1])\n\n\n# additive model with BIC (all vars deleted!!) ---------------------------------\nXy <- cbind(inp_mat_add, day_falling)\n# AIC backwards algorithm\nbest_add <- bestglm(Xy, IC = \"BIC\", method = \"backward\")\n\n# additive model with CV -------------------------------------------------------\nXy <- cbind(inp_mat_add, day_falling)\n# AIC backwards algorithm\nbest_add <- bestglm(Xy, IC = \"CV\")\n\n\n\n\nlibrary(glmulti)\n\n# LASSO -----------------------------------------------------------------\n# paper \"LASSO model selection with post-processing for a genome-wide association study data set\"\nlibrary(glmnet)\n\n\nmod <- glmnet(x = as.matrix(inp_mat), y = day_falling, family = \"gaussian\")\n\n# 1) Holgers method: testing every single SNP in a model and then\n# do a false discovery rate correction\n# qvalue or benjamini and hochberg\n\nophi <- ophi_add\n\nresults <- data.frame(row.names = names(ophi[3:ncol(ophi)]))\n\nfor (i in 3:ncol(ophi)) {\n        # fit model with disc size and one SNP as indepedent vars\n        fit2 <- glm(ophi[, 1] ~ ophi[, 2] + ophi[, i])\n        fit <- glm(ophi[, 1] ~ ophi[, 2])\n        model_comp <- anova(fit, fit2, test = \"F\")\n        \n        # get p values in vector\n        pval <- model_comp[2, 6]\n        fval <- model_comp[2, 5]\n        # extract pvalue from SNP\n        # pval <- summary(fit)$coef[, \"Pr(>|t|)\"][3]\n        \n        results[i-2, \"F\"] <- fval\n        results[i-2, \"pval\"] <- pval\n}\n\n# false discovery rate with qval\nlibrary(\"qvalue\")\n\n# lambda = 0 is Benjamini&Hochberg 1995; \nqval <- qvalue(results$pval,  pi0.method=\"smoother\")\n\nresults$qval <- qval$qvalue\nwrite.csv(results, \"single_models_het.csv\")\n\n# p-value cut off for a given false discovery rate level\nmax(qval$pvalues[qval$qvalues <= 0.5])\n\n\n# Joe: First try 98 models with disc size + each snp\n\nfit <- glm(ophi[, 1])\nfit2 <- glm(ophi[, 1] ~ ophi[, 2] + ophi[, i])\n\n\n\n# stepAIC backward-------------------------------------------------------------\nophi <- ophi_code\nophi <- ophi_het\nophi <- ophi_add\n\n# databin <- read.csv(\"C:/Users/Martin/Studium/Ophionotus/files/joedata.csv\", header = TRUE)\nnumVar <- ncol(ophi)\n\n# full model fit\nfit <- glm(ophi[, 1] ~. , data = ophi[, 2:numVar])\n\n# stepwise model selection AIC\nlibrary(MASS)\nstep <- stepAIC(fit, direction = \"backward\")\n\n# extract final model\nformula(step)\n\n# extract variable names\nmodnames <- attr(terms(step), \"term.labels\")\n\n# construct data frame with F and P values of each variable in the final Model\nophired <- cbind(ophi[1], ophi[, modnames])\n\n# deletion test every variable\nvals <- DelTestVar(ophired)\n\n# reduce data frame \nval_red <- vals[2:(length(modnames)+1), ]\nval_red2 <- (val_red[, c(\"F\",\"P (F-test)\")])\n\n# give the right names (not factor levels)\nrow.names(val_red2) <- modnames\n\n# sort within all SNP´s\nfinal_snp_df <- data.frame(\"F\" = rep(NA, 98), \"pval\" = rep(NA, 98), row.names = names(ophi)[3:ncol(ophi)])\n\n# fill in the final AIC model\nfinal_snp_df[row.names(val_red2), ] <- val_red2\nwrite.csv(final_snp_df, \"stepAICbackHetFac.csv\")\n\n\n# minmodelr------------------------------------------------------------------\nlibrary(minmodelr)\nophi_list <- list(ophi_add, ophi_het)\n\nall_models <- lapply(ophi_list, MinMod)\n\n\n\n# test crawley models again full models\n\n# dependent var\nday_falling <- ophi_add[, 1]\n\n# additive\nfullmod_add <- glm(day_falling ~., data=ophi_add[, 2:ncol(ophi_add)])\ncrawley_add <- all_models[[1]][[1]]\nadd_mod <- glm(day_falling ~., data = crawley_add[, 2:ncol(crawley_add)])\nanova_add <- anova(fullmod_add,add_mod, test = \"F\")\n\n# het\nfullmod_het <- glm(day_falling ~., data = ophi_het[, 2:ncol(ophi_het)])\ncrawley_het <- all_models[[3]][[1]][-c(3:11)]\nhet_mod <- glm(day_falling ~., data = crawley_het[, 2:ncol(crawley_het)])\nanova_het <- anova(fullmod_het, het_mod, test = \"F\")\n\n\n# plot anova for every variable ------------------------------------------------\n\ngive.n <- function(x){\n        return(c(y = mean(x), label = length(x)))\n}\n\ncode_df <- all_models[[2]][[1]]\nhet_df <- all_models[[3]][[1]]\nadd_df <- all_models[[1]][[1]]\n\n# change to factor for proper boxplots\nadd_df[, 2:ncol(add_df)] <- lapply((add_df[, 2:ncol(add_df)]), as.factor)\nall_plots <- list()\nfor (i in names(add_df)[2:ncol(add_df)]) {\n\n        # plot boxplots for \n        p <- ggplot(add_df, aes_string(y = \"depVar\", x = i)) + \n                geom_boxplot() + \n                stat_summary(fun.data = give.n, geom = \"text\", size = 10) +\n                ylab(\"day falling\") +\n                theme_classic(base_size = 20)\n        (assign(i, p))\n}\n\nfor (i in names(add_df)[2:ncol(add_df)]) {\n        \n        # plot boxplots for \n        p <- ggplot(add_df, aes_string(y = \"depVar\", x = i)) + \n                geom_point() +\n                stat_smooth(method = lm) + \n               stat_summary(fun.data = give.n, geom = \"text\", size = 10) +\n                ylab(\"day falling\") +\n                theme_classic(base_size = 20)\n        (assign(i, p))\n}\n\nsource(\"multiplot.R\")\nmultiplot(het_imp_14, het_imp_3, het_imp_33, het_imp_47, het_imp_53,\n          het_imp_58, het_imp_66,het_imp_75,het_imp_79,het_imp_95, cols = 2)\n\nmultiplot(code_imp_1, code_imp_10, code_imp_59, code_imp_61, code_imp_88, code_imp_97, cols = 2)\n\n\n# data frame \nadd_df <- all_models[[1]][[1]]\nadd_mod <- all_models[[1]][[2]]\nadd_df2 <- data.frame(code_imp_1 = seq(min(het_df$code_imp_1), max(het_df$code_imp_1), 0.02),\n                      code_imp_10 = mean(het_df$code_imp_10),\n                      code_imp_59 = mean(het_df$code_imp_59),\n                      code_imp_61 = mean(het_df$code_imp_61),\n                      code_imp_88 = mean(het_df$code_imp_88),\n                      code_imp_97 = mean(het_df$code_imp_97))\n\nadd_df2$code_imp_1_pred <- predict(add_mod, add_df2, type = \"response\")\n\n                                   \nbestmod <- MinMod(ophi) \nmodnames <- attr(terms(bestmod[[2]]), \"term.labels\")\n\n\n# get fitted values with predict\ndf <- bestmod[[1]]\ndf2 <- data.frame(het_imp_3 = seq(min(df$het_imp_3), max(df$het_imp_3, 0.02), het_imp_14 = mean(het_imp_14)))\n\n\n\n# construct data frame with F and P values \n# of each variable in the final Model-----------------\nophired <- cbind(ophi[1], ophi[, modnames])\n\n# deletion test every variable\nvals <- DelTestVar(ophired)\n\n# reduce data frame \nval_red <- vals[2:(length(modnames)+1), ]\nval_red2 <- (val_red[, c(\"F\",\"P (F-test)\")])\n\n# give the right names (not factor levels)\nrow.names(val_red2) <- modnames\n\n# sort within all SNP´s\nfinal_snp_df <- data.frame(\"F\" = rep(NA, 98), \"pval\" = rep(NA, 98), row.names = names(ophi)[3:ncol(ophi)])\n\n# fill in the final AIC model\nfinal_snp_df[row.names(val_red2), ] <- val_red2\n\n# het data\nmod <- bestmod[[2]]\ndata <- bestmod[[1]]\n\n\n\n\n# using granova package to visualize\nlibrary(granovaGG)\np <- granovagg.1w(data=data[, 1], \n        group = ((data[, 7])))\nprint(p)\nwrite.csv(final_snp_df, \"crawleyhet.csv\")\n\nbestmod2 <- minmodelr(ophi)\n\nlibrary(leaps)\nleaps <- regsubsets(ophi[, 1] ~. , data = ophi[, 3:numVar], nbest = 2)\n\n## num vars\nnumVar <- ncol(datafac)\ndatafac[, 3:numVar] <- lapply(data[, 3:numVar], factor)\nmodel <- MinMod(datafac)\ntestmodel <- glm(datafac[, 1] ~. , data = datafac[, 2:numVar])\nmodels <- glmulti(day_falling ~., data = subset(datafac, select = 1:20), method = \"g\", level=1)\n\n## other best subset approaches\n# glmulti, bestglm, leaps, step, stepAIC      (all based on AIC!)\nlibrary(glmulti)\nmod <- glm(day_falling ~., data = ophi_add)\nresults <- glmulti(mod, method = \"l\", level = 1)\n\n# lasso\nlibrary(glmnet)\ninp_add <- as.matrix(ophi_het[2:ncol(ophi_het)])\ny <- ophi_add[, 1]\n\ngrid <- 10^seq(10, -2, length = 100)\n\nset.seed(1)\ntrain <- sample(1:nrow(ophi_add), nrow(ophi_add)/2)\ntest <- (-train)\ny.test <- y[test]\n\nmod <- glmnet(x = inp_add[train, ], y = y[train], alpha = 1, lambda = grid)\nplot(mod)\n\nset.seed(1)\ncv.out <- cv.glmnet(inp_add[train, ], y[train], alpha = 1)\nplot(cv.out)\nbestlam <- cv.out$lambda.min\nlasso.pred <- predict(mod, s = bestlam, newx = inp_add[test, ])\nmean((lasso.pred-y.test)^2)\n\n# mean with just the intercept\nmean((mean(y[train]) - y.test)^2)\n\n# variable selection by lasso\nout <- glmnet(inp_add, y, alpha=1, lambda = grid)\nlasso.coef <- predict(out, type=\"coefficients\", s= bestlam)\nlasso.coef\n",
    "created" : 1424269823464.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "651900196",
    "id" : "23358CC7",
    "lastKnownWriteTime" : 1417536180,
    "path" : "C:/Users/Martin/Studium/projects/ophionotus/brittlestar.R",
    "project_path" : "brittlestar.R",
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "type" : "r_source"
}